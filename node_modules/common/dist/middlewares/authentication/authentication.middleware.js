"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.authenticateRequest = void 0;
const repositories_1 = require("./../../repositories");
const utils_1 = require("./../../utils");
const role_resolver_1 = require("./role-resolver");
const fs = require('fs');
const os = require('os');
const authenticateRequest = async function (requestContext, next) {
    var _a, _b;
    const userProfile = { resolvedRoles: ['$everyone'] };
    var { request, response } = requestContext;
    const headers = request.headers;
    const API_KEY = process.env.COMMON_API_KEY;
    //Throw error if no API key set
    if (!API_KEY) {
        throw Error('API KEY not present');
    }
    if (!('trxid' in request.headers)) {
        var trxId = createTransactionId();
        request.headers['TrxId'] = trxId;
    }
    //If Transaction Id is available, use the existing one
    else {
        var trxId = headers['trxid'];
    }
    let additionalHeaders = {
        headers: {
            Authorization: API_KEY,
            TrxId: trxId,
            source: 'external-system'
        }
    };
    userProfile['TrxId'] = trxId;
    userProfile['ip'] = (_a = headers['x-forwarded-for']) !== null && _a !== void 0 ? _a : request.ip;
    //If request coming from external system
    var authorizationToken = '';
    var tokenData = {};
    //check if request is from one of the other microservices
    if (('Authorization' in headers || 'authorization' in headers) &&
        'trxid' in headers &&
        'source' in headers &&
        headers.source === 'external-system' &&
        (headers['Authorization'] === API_KEY || headers['authorization'] === API_KEY)) {
        // additionalHeaders.headers.TrxId = headers.TrxId
        userProfile.resolvedRoles = ['external-system'];
    }
    else {
        if (!('Authorization' in headers || 'authorization' in headers)) {
            userProfile.resolvedRoles.push('$unAuthenticated');
        }
        else {
            //check if the auth Token is valid
            const appAccessTokenRepository = await this.getRepository(repositories_1.AppAccessTokenRepository);
            authorizationToken = headers['Authorization'] || headers['authorization'];
            let foundUser = await appAccessTokenRepository
                .findOne({
                where: {
                    token: authorizationToken
                }
            }, additionalHeaders)
                .catch(async (err) => {
                utils_1.LoggingUtils.error(err);
                // throw err;
                //setting HSTS header beforte ending request
                response.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
                response.status(401).send('Something went wrong!');
            });
            if (foundUser && foundUser.expiry) {
                const curreDate = new Date();
                const accessTokenExpiryDate = new Date(foundUser.expiry);
                //if the isActive Column is false it means that another user has logged in. This is later checked in the authorization middleware
                if (foundUser.isActive === false) {
                    foundUser = null;
                    userProfile['anotherUserLoggedIn'] = true;
                }
                //if the token has expired. This is later checked in the authorization middleware
                else if (curreDate > accessTokenExpiryDate) {
                    foundUser = null;
                    userProfile['isExpired'] = true;
                }
            }
            //If invalid, add $unAuthenticatd
            if (!foundUser || !foundUser.tokenData)
                userProfile.resolvedRoles.push('$unAuthenticated');
            else {
                tokenData = (_b = foundUser === null || foundUser === void 0 ? void 0 : foundUser.tokenData) !== null && _b !== void 0 ? _b : {};
                if (!tokenData.appRoles)
                    tokenData.appRoles = []; //Adding this as some existing tokenData doesn't have appRoles
                userProfile.resolvedRoles = [...userProfile.resolvedRoles, ...tokenData.appRoles];
                userProfile.resolvedRoles.push('$authenticated');
                if (!tokenData.accessibleAppUserIds)
                    tokenData['accessibleAppUserIds'] = [tokenData.appUserId];
                const roleResolver = new role_resolver_1.RoleResolver(request, tokenData);
                const resolvedRolesFromRoleResolver = roleResolver.resolveRoles();
                //If the token is generated by verifyotp and the resolved role includes $owner, then we attach the $otpVerified role
                if (tokenData.appRoles.includes('$otpVerified')) {
                    if (!resolvedRolesFromRoleResolver.includes('$owner')) {
                        userProfile.resolvedRoles = userProfile.resolvedRoles.filter((role) => role !== '$otpVerified'); // remove the $otpVerified role in case $owner wasn't established for the user
                    }
                }
                else {
                    userProfile.resolvedRoles = [...userProfile.resolvedRoles, ...resolvedRolesFromRoleResolver];
                }
            }
        }
    }
    const userProfileData = { ...tokenData, ...userProfile };
    const auditLogParams = createAuditLogParams(additionalHeaders, userProfileData, request);
    additionalHeaders = { ...additionalHeaders, logParams: auditLogParams };
    requestContext.bind('userProfile').to(userProfileData);
    requestContext.bind('additionalHeaders').to(additionalHeaders);
    const result = await next();
    return result;
};
exports.authenticateRequest = authenticateRequest;
const createTransactionId = () => {
    return Date.now() + utils_1.RandomizationUtils.generateUniqueId(16);
};
const createAuditLogParams = (additionalHeaders, userProfile, request) => {
    var _a;
    const optionsForAuditing = {
        doAuditLog: false,
        transactionId: additionalHeaders.headers.TrxId,
        ipAddress: (_a = request.headers['x-forwarded-for']) !== null && _a !== void 0 ? _a : request.ip,
        hostName: request.hostname,
        source: 'unknown',
        version: 'unknown',
        appUserId: userProfile.appUserId,
        url: request.originalUrl,
        query: request.query
    };
    if (request.headers.source)
        optionsForAuditing.source = request.headers.source;
    if (request.headers.version)
        optionsForAuditing.version = request.headers.version;
    if (userProfile.appRoleIds && userProfile.appRoleIds.some((id) => id > 1))
        optionsForAuditing.doAuditLog = true; // As audit log is only for Operations users
    return optionsForAuditing;
};
//# sourceMappingURL=authentication.middleware.js.map